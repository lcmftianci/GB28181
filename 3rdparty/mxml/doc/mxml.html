<!DOCTYPE html>
<html lang="en-US">
<head>
<title>Mini-XML 3.3 Programming Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="generator" content="codedoc v3.7">
<meta name="author" content="Michael R Sweet">
<meta name="language" content="en-US">
<meta name="copyright" content="Copyright © 2003-2021, All Rights Reserved.">
<meta name="version" content="3.3">
<style type="text/css"><!--
body {
  background: white;
  color: black;
  font-family: sans-serif;
  font-size: 12pt;
}
a {
  color: black;
}
a:link, a:visited {
  color: #00f;
}
a:link:hover, a:visited:hover, a:active {
  color: #c0c;
}
body, p, h1, h2, h3, h4, h5, h6 {
  font-family: sans-serif;
  line-height: 1.4;
}
h1, h2, h3, h4, h5, h6 {
  font-weight: bold;
  page-break-inside: avoid;
}
h1 {
  font-size: 250%;
  margin: 0;
}
h2 {
  font-size: 250%;
  margin-top: 1.5em;
}
h3 {
  font-size: 200%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h4 {
  font-size: 150%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h5 {
  font-size: 125%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h6 {
  font-size: 110%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
img.title {
  width: 256px;
}
div.header h1, div.header p {
  text-align: center;
}
div.contents, div.body, div.footer {
  page-break-before: always;
}
.class, .enumeration, .function, .struct, .typedef, .union {
  border-bottom: solid 2px gray;
}
.description {
  margin-top: 0.5em;
}
.function {
  margin-bottom: 0;
}
blockquote {
  border: solid thin gray;
  box-shadow: 3px 3px 5px rgba(127,127,127,0.25);
  margin: 1em 0;
  padding: 10px;
  page-break-inside: avoid;
}
p code, li code, p.code, pre, ul.code li {
  font-family: monospace;
  hyphens: manual;
  -webkit-hyphens: manual;
}
p.code, pre, ul.code li {
  background: rgba(127,127,127,0.25);
  border: thin dotted gray;
  padding: 10px;
  page-break-inside: avoid;
}
pre {
  white-space: pre-wrap;
}
a:link, a:visited {
  text-decoration: none;
}
span.info {
  background: black;
  border: solid thin black;
  color: white;
  font-size: 80%;
  font-style: italic;
  font-weight: bold;
  white-space: nowrap;
}
h1 span.info, h2 span.info, h3 span.info, h4 span.info {
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  float: right;
  padding: 3px 6px;
}
ul.code, ul.contents, ul.subcontents {
  list-style-type: none;
  margin: 0;
  padding-left: 0;
}
ul.code li {
  margin: 0;
}
ul.contents > li {
  margin-top: 1em;
}
ul.contents li ul.code, ul.contents li ul.subcontents {
  padding-left: 2em;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td {
  border: solid 1px gray;
  padding: 5px 10px;
  vertical-align: top;
}
td.left {
  text-align: left;
}
td.center {
  text-align: center;
}
td.right {
  text-align: right;
}
th {
  border-bottom: solid 2px gray;
  padding: 1px 5px;
  text-align: center;
  vertical-align: bottom;
}
tr:nth-child(even) {
  background: rgba(127,127,127,0.25);
}
table.list {
  border-collapse: collapse;
  width: 100%;
}
table.list th {
  border-bottom: none;
  border-right: 2px solid gray;
  font-family: monospace;
  font-weight: normal;
  padding: 5px 10px 5px 2px;
  text-align: right;
  vertical-align: top;
}
table.list td {
  border: none;
  padding: 5px 2px 5px 10px;
  text-align: left;
  vertical-align: top;
}
h2.title, h3.title {
  border-bottom: solid 2px gray;
}
/* Syntax highlighting */
span.comment {
  color: darkgreen;
}
span.directive {
  color: purple;
}
span.number {
  color: brown;
}
span.reserved {
  color: darkcyan;
}
span.string {
  color: magenta;
}
/* Dark mode overrides */
@media (prefers-color-scheme: dark) {
  body {
    background: black;
    color: #ccc;
  }
  a {
    color: #ccc;
  }
  a:link, a:visited {
    color: #66f;
  }
  a:link:hover, a:visited:hover, a:active {
    color: #f06;
  }
}
/* Show contents on left side in web browser */
@media screen and (min-width: 800px) {
  div.contents {
    border-right: solid thin gray;
    bottom: 0px;
    box-shadow: 3px 3px 5px rgba(127,127,127,0.5);
    font-size: 10pt;
    left: 0px;
    overflow: scroll;
    padding: 1%;
    position: fixed;
    top: 0px;
    width: 18%;
  }
  div.contents h2.title {
    margin-top: 0px;
  }
  div.header, div.body, div.footer {
    margin-left: 20%;
    padding: 1% 2%;
  }
}
/* Center title page content vertically */
@media print {
  div.header {
    padding-top: 33%;
  }
}
--></style>
</head>
<body>
<div class="header">
<p><img class="title" src="mxml-cover.png"></p>
<h1 class="title">Mini-XML 3.3 Programming Manual</h1>
<p>Michael R Sweet</p>
<p>Copyright © 2003-2021, All Rights Reserved.</p>
</div>
<div class="contents">
<h2 class="title">Contents</h2>
<ul class="contents">
<li><a href="#introduction">Introduction</a><ul class="subcontents">
<li><a href="#history">History</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#legal-stuff">Legal Stuff</a></li>
</ul></li>
<li><a href="#using-mini-xml">Using Mini-XML</a><ul class="subcontents">
<li><a href="#loading-an-xml-file">Loading an XML File</a></li>
<li><a href="#nodes">Nodes</a></li>
<li><a href="#creating-xml-documents">Creating XML Documents</a></li>
<li><a href="#saving-an-xml-file">Saving an XML File</a></li>
<li><a href="#memory-management">Memory Management</a></li>
</ul></li>
<li><a href="#more-about-nodes">More About Nodes</a><ul class="subcontents">
<li><a href="#element-nodes">Element Nodes</a></li>
<li><a href="#cdata-nodes">CDATA Nodes</a></li>
<li><a href="#comment-nodes">Comment Nodes</a></li>
<li><a href="#processing-instruction-nodes">Processing Instruction Nodes</a></li>
<li><a href="#integer-nodes">Integer Nodes</a></li>
<li><a href="#opaque-string-nodes">Opaque String Nodes</a></li>
<li><a href="#text-nodes">Text Nodes</a></li>
<li><a href="#real-number-nodes">Real Number Nodes</a></li>
</ul></li>
<li><a href="#locating-data-in-an-xml-document">Locating Data in an XML Document</a><ul class="subcontents">
<li><a href="#finding-nodes">Finding Nodes</a></li>
<li><a href="#iterating-nodes">Iterating Nodes</a></li>
<li><a href="#indexing">Indexing</a></li>
</ul></li>
<li><a href="#custom-data-types">Custom Data Types</a></li>
<li><a href="#sax-stream-loading-of-documents">SAX (Stream) Loading of Documents</a></li>
<li><a href="#FUNCTIONS">Functions</a><ul class="subcontents">
<li><a href="#mxmlAdd">mxmlAdd</a></li>
<li><a href="#mxmlDelete">mxmlDelete</a></li>
<li><a href="#mxmlElementDeleteAttr">mxmlElementDeleteAttr</a></li>
<li><a href="#mxmlElementGetAttr">mxmlElementGetAttr</a></li>
<li><a href="#mxmlElementGetAttrByIndex">mxmlElementGetAttrByIndex</a></li>
<li><a href="#mxmlElementGetAttrCount">mxmlElementGetAttrCount</a></li>
<li><a href="#mxmlElementSetAttr">mxmlElementSetAttr</a></li>
<li><a href="#mxmlElementSetAttrf">mxmlElementSetAttrf</a></li>
<li><a href="#mxmlEntityAddCallback">mxmlEntityAddCallback</a></li>
<li><a href="#mxmlEntityGetName">mxmlEntityGetName</a></li>
<li><a href="#mxmlEntityGetValue">mxmlEntityGetValue</a></li>
<li><a href="#mxmlEntityRemoveCallback">mxmlEntityRemoveCallback</a></li>
<li><a href="#mxmlFindElement">mxmlFindElement</a></li>
<li><a href="#mxmlFindPath">mxmlFindPath</a></li>
<li><a href="#mxmlGetCDATA">mxmlGetCDATA</a></li>
<li><a href="#mxmlGetCustom">mxmlGetCustom</a></li>
<li><a href="#mxmlGetElement">mxmlGetElement</a></li>
<li><a href="#mxmlGetFirstChild">mxmlGetFirstChild</a></li>
<li><a href="#mxmlGetInteger">mxmlGetInteger</a></li>
<li><a href="#mxmlGetLastChild">mxmlGetLastChild</a></li>
<li><a href="#mxmlGetNextSibling">mxmlGetNextSibling</a></li>
<li><a href="#mxmlGetOpaque">mxmlGetOpaque</a></li>
<li><a href="#mxmlGetParent">mxmlGetParent</a></li>
<li><a href="#mxmlGetPrevSibling">mxmlGetPrevSibling</a></li>
<li><a href="#mxmlGetReal">mxmlGetReal</a></li>
<li><a href="#mxmlGetRefCount">mxmlGetRefCount</a></li>
<li><a href="#mxmlGetText">mxmlGetText</a></li>
<li><a href="#mxmlGetType">mxmlGetType</a></li>
<li><a href="#mxmlGetUserData">mxmlGetUserData</a></li>
<li><a href="#mxmlIndexDelete">mxmlIndexDelete</a></li>
<li><a href="#mxmlIndexEnum">mxmlIndexEnum</a></li>
<li><a href="#mxmlIndexFind">mxmlIndexFind</a></li>
<li><a href="#mxmlIndexGetCount">mxmlIndexGetCount</a></li>
<li><a href="#mxmlIndexNew">mxmlIndexNew</a></li>
<li><a href="#mxmlIndexReset">mxmlIndexReset</a></li>
<li><a href="#mxmlLoadFd">mxmlLoadFd</a></li>
<li><a href="#mxmlLoadFile">mxmlLoadFile</a></li>
<li><a href="#mxmlLoadString">mxmlLoadString</a></li>
<li><a href="#mxmlNewCDATA">mxmlNewCDATA</a></li>
<li><a href="#mxmlNewCustom">mxmlNewCustom</a></li>
<li><a href="#mxmlNewElement">mxmlNewElement</a></li>
<li><a href="#mxmlNewInteger">mxmlNewInteger</a></li>
<li><a href="#mxmlNewOpaque">mxmlNewOpaque</a></li>
<li><a href="#mxmlNewOpaquef">mxmlNewOpaquef</a></li>
<li><a href="#mxmlNewReal">mxmlNewReal</a></li>
<li><a href="#mxmlNewText">mxmlNewText</a></li>
<li><a href="#mxmlNewTextf">mxmlNewTextf</a></li>
<li><a href="#mxmlNewXML">mxmlNewXML</a></li>
<li><a href="#mxmlRelease">mxmlRelease</a></li>
<li><a href="#mxmlRemove">mxmlRemove</a></li>
<li><a href="#mxmlRetain">mxmlRetain</a></li>
<li><a href="#mxmlSAXLoadFd">mxmlSAXLoadFd</a></li>
<li><a href="#mxmlSAXLoadFile">mxmlSAXLoadFile</a></li>
<li><a href="#mxmlSAXLoadString">mxmlSAXLoadString</a></li>
<li><a href="#mxmlSaveAllocString">mxmlSaveAllocString</a></li>
<li><a href="#mxmlSaveFd">mxmlSaveFd</a></li>
<li><a href="#mxmlSaveFile">mxmlSaveFile</a></li>
<li><a href="#mxmlSaveString">mxmlSaveString</a></li>
<li><a href="#mxmlSetCDATA">mxmlSetCDATA</a></li>
<li><a href="#mxmlSetCustom">mxmlSetCustom</a></li>
<li><a href="#mxmlSetCustomHandlers">mxmlSetCustomHandlers</a></li>
<li><a href="#mxmlSetElement">mxmlSetElement</a></li>
<li><a href="#mxmlSetErrorCallback">mxmlSetErrorCallback</a></li>
<li><a href="#mxmlSetInteger">mxmlSetInteger</a></li>
<li><a href="#mxmlSetOpaque">mxmlSetOpaque</a></li>
<li><a href="#mxmlSetOpaquef">mxmlSetOpaquef</a></li>
<li><a href="#mxmlSetReal">mxmlSetReal</a></li>
<li><a href="#mxmlSetText">mxmlSetText</a></li>
<li><a href="#mxmlSetTextf">mxmlSetTextf</a></li>
<li><a href="#mxmlSetUserData">mxmlSetUserData</a></li>
<li><a href="#mxmlSetWrapMargin">mxmlSetWrapMargin</a></li>
<li><a href="#mxmlWalkNext">mxmlWalkNext</a></li>
<li><a href="#mxmlWalkPrev">mxmlWalkPrev</a></li>
</ul></li>
<li><a href="#TYPES">Data Types</a><ul class="subcontents">
<li><a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a></li>
<li><a href="#mxml_custom_load_cb_t">mxml_custom_load_cb_t</a></li>
<li><a href="#mxml_custom_save_cb_t">mxml_custom_save_cb_t</a></li>
<li><a href="#mxml_entity_cb_t">mxml_entity_cb_t</a></li>
<li><a href="#mxml_error_cb_t">mxml_error_cb_t</a></li>
<li><a href="#mxml_index_t">mxml_index_t</a></li>
<li><a href="#mxml_load_cb_t">mxml_load_cb_t</a></li>
<li><a href="#mxml_node_t">mxml_node_t</a></li>
<li><a href="#mxml_save_cb_t">mxml_save_cb_t</a></li>
<li><a href="#mxml_sax_cb_t">mxml_sax_cb_t</a></li>
<li><a href="#mxml_sax_event_t">mxml_sax_event_t</a></li>
<li><a href="#mxml_type_t">mxml_type_t</a></li>
</ul></li>
<li><a href="#ENUMERATIONS">Enumerations</a><ul class="subcontents">
<li><a href="#mxml_sax_event_e">mxml_sax_event_e</a></li>
<li><a href="#mxml_type_e">mxml_type_e</a></li>
</ul></li>
</ul>
</div>
<div class="body">
<h2 class="title" id="introduction">Introduction</h2>
<p>Mini-XML is a small XML parsing library that you can use to read XML data files or strings in your application without requiring large non-standard libraries. Mini-XML provides the following functionality:</p>
<ul>
<li><p>Reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings.</p>
</li>
<li><p>Data is stored in a linked-list tree structure, preserving the XML data hierarchy.</p>
</li>
<li><p>SAX (streamed) reading of XML files and strings to minimize memory usage.</p>
</li>
<li><p>Supports arbitrary element names, attributes, and attribute values with no preset limits, just available memory.</p>
</li>
<li><p>Supports integer, real, opaque (&quot;cdata&quot;), and text data types in &quot;leaf&quot; nodes.</p>
</li>
<li><p>Functions for creating and managing trees of data.</p>
</li>
<li><p>&quot;Find&quot; and &quot;walk&quot; functions for easily locating and navigating trees of data.</p>
</li>
</ul>
<p>Mini-XML doesn't do validation or other types of processing on the data based upon schema files or other sources of definition information.</p>
<h3 class="title" id="history">History</h3>
<p>Mini-XML was initially developed for the <a href="http://gutenprint.sf.net/">Gutenprint</a> project to replace the rather large and unwieldy <code>libxml2</code> library with something substantially smaller and easier-to-use. It all began one morning in June of 2003 when Robert posted the following sentence to the developer's list:</p>
<blockquote>
<p>It's bad enough that we require libxml2, but rolling our own XML parser is a bit more than we can handle.</p>
</blockquote>
<p>I then replied with:</p>
<blockquote>
<p>Given the limited scope of what you use in XML, it should be trivial to code a mini-XML API in a few hundred lines of code.</p>
</blockquote>
<p>I took my own challenge and coded furiously for two days to produced the initial public release of Mini-XML, total lines of code: 696. Robert promptly integrated Mini-XML into Gutenprint and removed libxml2.</p>
<p>Thanks to lots of feedback and support from various developers, Mini-XML has evolved since then to provide a more complete XML implementation and now stands at a whopping 4,300 lines of code, compared to 196,141 lines of code for libxml2 version 2.9.9.</p>
<h3 class="title" id="resources">Resources</h3>
<p>The Mini-XML home page can be found at <a href="https://www.msweet.org/mxml">https://www.msweet.org/mxml</a>. From there you can download the current version of Mini-XML, access the issue tracker, and find other resources.</p>
<h3 class="title" id="legal-stuff">Legal Stuff</h3>
<p>The Mini-XML library is copyright © 2003-2021 by Michael R Sweet and is provided under the Apache License Version 2.0 with an exception to allow linking against GPL2/LGPL2-only software. See the files &quot;LICENSE&quot; and &quot;NOTICE&quot; for more information.</p>
<h2 class="title" id="using-mini-xml">Using Mini-XML</h2>
<p>Mini-XML provides a single header file which you include:</p>
<pre><code>#include &lt;mxml.h&gt;
</code></pre>
<p>The Mini-XML library is included with your program using the <code>-lmxml</code> option:</p>
<pre><code>gcc -o myprogram myprogram.c -lmxml
</code></pre>
<p>If you have the <code>pkg-config</code> software installed, you can use it to determine the proper compiler and linker options for your installation:</p>
<pre><code>gcc `pkg-config --cflags mxml` -o myprogram myprogram.c `pkg-config --libs mxml`
</code></pre>
<h3 class="title" id="loading-an-xml-file">Loading an XML File</h3>
<p>You load an XML file using the <code>mxmlLoadFile</code> function:</p>
<pre><code>mxml_node_t *
mxmlLoadFile(mxml_node_t *top, FILE *fp,
             mxml_type_t (*cb)(mxml_node_t *));
</code></pre>
<p>The <code>cb</code> argument specifies a function that assigns child (value) node types for each element in the document. The callback can be a function you provide or one of the standard functions provided with Mini-XML. For example, to load the XML file &quot;filename.xml&quot; containing text strings you can use the <code>MXML_OPAQUE_CALLBACK</code> function:</p>
<pre><code>FILE *fp;
mxml_node_t *tree;

fp = fopen(&quot;filename.xml&quot;, &quot;r&quot;);
tree = mxmlLoadFile(NULL, fp, MXML_OPAQUE_CALLBACK);
fclose(fp);
</code></pre>
<p>Mini-XML also provides functions to load from a file descriptor or string:</p>
<pre><code>mxml_node_t *
mxmlLoadFd(mxml_node_t *top, int fd,
           mxml_type_t (*cb)(mxml_node_t *));

mxml_node_t *
mxmlLoadString(mxml_node_t *top, const char *s,
               mxml_type_t (*cb)(mxml_node_t *));
</code></pre>
<h4 id="load-callbacks">Load Callbacks</h4>
<p>The last argument to the <code>mxmlLoad</code> functions is a callback function which is used to determine the value type of each data node in an XML document. Mini-XML defines several standard callbacks for simple XML data files:</p>
<ul>
<li><p><code>MXML_INTEGER_CALLBACK</code>: All data nodes contain whitespace-separated integers.</p>
</li>
<li><p><code>MXML_OPAQUE_CALLBACK</code>: All data nodes contain opaque strings with whitespace preserved.</p>
</li>
<li><p><code>MXML_REAL_CALLBACK</code> - All data nodes contain whitespace-separated floating-point numbers.</p>
</li>
<li><p><code>MXML_TEXT_CALLBACK</code> - All data nodes contain whitespace-separated strings.</p>
</li>
</ul>
<p>You can provide your own callback functions for more complex XML documents. Your callback function will receive a pointer to the current element node and must return the value type of the immediate children for that element node: <code>MXML_CUSTOM</code>, <code>MXML_INTEGER</code>, <code>MXML_OPAQUE</code>, <code>MXML_REAL</code>, or <code>MXML_TEXT</code>. The function is called <em>after</em> the element and its attributes have been read, so you can look at the element name, attributes, and attribute values to determine the proper value type to return.</p>
<p>The following callback function looks for an attribute named &quot;type&quot; or the element name to determine the value type for its child nodes:</p>
<pre><code>mxml_type_t
type_cb(mxml_node_t *node)
{
  const char *type;

 /*
  * You can lookup attributes and/or use the element name,
  * hierarchy, etc...
  */

  type = mxmlElementGetAttr(node, &quot;type&quot;);
  if (type == NULL)
    type = mxmlGetElement(node);

  if (!strcmp(type, &quot;integer&quot;))
    return (MXML_INTEGER);
  else if (!strcmp(type, &quot;opaque&quot;))
    return (MXML_OPAQUE);
  else if (!strcmp(type, &quot;real&quot;))
    return (MXML_REAL);
  else
    return (MXML_TEXT);
}
</code></pre>
<p>To use this callback function, simply use the name when you call any of the load functions:</p>
<pre><code>FILE *fp;
mxml_node_t *tree;

fp = fopen(&quot;filename.xml&quot;, &quot;r&quot;);
tree = mxmlLoadFile(NULL, fp, type_cb);
fclose(fp);
</code></pre>
<h3 class="title" id="nodes">Nodes</h3>
<p>Every piece of information in an XML file is stored in memory in &quot;nodes&quot;. Nodes are defined by the <code>mxml_node_t</code> structure. Each node has a typed value, optional user data, a parent node, sibling nodes (previous and next), and potentially child nodes.</p>
<p>For example, if you have an XML file like the following:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;data&gt;
    &lt;node&gt;val1&lt;/node&gt;
    &lt;node&gt;val2&lt;/node&gt;
    &lt;node&gt;val3&lt;/node&gt;
    &lt;group&gt;
        &lt;node&gt;val4&lt;/node&gt;
        &lt;node&gt;val5&lt;/node&gt;
        &lt;node&gt;val6&lt;/node&gt;
    &lt;/group&gt;
    &lt;node&gt;val7&lt;/node&gt;
    &lt;node&gt;val8&lt;/node&gt;
&lt;/data&gt;
</code></pre>
<p>the node tree for the file would look like the following in memory:</p>
<pre><code>?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?
  |
data
  |
node - node - node - group - node - node
  |      |      |      |       |      |
val1   val2   val3     |     val7   val8
                       |
                     node - node - node
                       |      |      |
                     val4   val5   val6
</code></pre>
<p>where &quot;-&quot; is a pointer to the sibling node and &quot;|&quot; is a pointer to the first child or parent node.</p>
<p>The <code>mxmlGetType</code> function gets the type of a node:</p>
<pre><code>mxml_type_t
mxmlGetType(mxml_node_t *node);
</code></pre>
<ul>
<li><p><code>MXML_CUSTOM</code> : A custom value defined by your application,</p>
</li>
<li><p><code>MXML_ELEMENT</code> : An XML element, CDATA, comment, or processing instruction,</p>
</li>
<li><p><code>MXML_INTEGER</code> : A whitespace-delimited integer value,</p>
</li>
<li><p><code>MXML_OPAQUE</code> : An opaque string value that preserves all whitespace,</p>
</li>
<li><p><code>MXML_REAL</code> : A whitespace-delimited floating point value, or</p>
</li>
<li><p><code>MXML_TEXT</code> : A whitespace-delimited text (fragment) value.</p>
</li>
</ul>
<blockquote>
<p>Note: CDATA, comment, and processing directive nodes are currently stored in memory as special elements. This will be changed in a future major release of Mini-XML.</p>
</blockquote>
<p>The parent and sibling nodes are accessed using the <code>mxmlGetParent</code>, <code>mxmlGetNextSibling</code>, and <code>mxmlGetPreviousSibling</code> functions, while the children of an element node are accessed using the <code>mxmlGetFirstChild</code> or <code>mxmlGetLastChild</code> functions:</p>
<pre><code>mxml_node_t *
mxmlGetFirstChild(mxml_node_t *node);

mxml_node_t *
mxmlGetLastChild(mxml_node_t *node);

mxml_node_t *
mxmlGetNextSibling(mxml_node_t *node);

mxml_node_t *
mxmlGetParent(mxml_node_t *node);

mxml_node_t *
mxmlGetPrevSibling(mxml_node_t *node);
</code></pre>
<p>The <code>mxmlGetUserData</code> function gets any user (application) data associated with the node:</p>
<pre><code>void *
mxmlGetUserData(mxml_node_t *node);
</code></pre>
<h3 class="title" id="creating-xml-documents">Creating XML Documents</h3>
<p>You can create and update XML documents in memory using the various <code>mxmlNew</code> functions. The following code will create the XML document described in the previous section:</p>
<pre><code>mxml_node_t *xml;    /* &lt;?xml ... ?&gt; */
mxml_node_t *data;   /* &lt;data&gt; */
mxml_node_t *node;   /* &lt;node&gt; */
mxml_node_t *group;  /* &lt;group&gt; */

xml = mxmlNewXML(&quot;1.0&quot;);

data = mxmlNewElement(xml, &quot;data&quot;);

    node = mxmlNewElement(data, &quot;node&quot;);
    mxmlNewText(node, 0, &quot;val1&quot;);
    node = mxmlNewElement(data, &quot;node&quot;);
    mxmlNewText(node, 0, &quot;val2&quot;);
    node = mxmlNewElement(data, &quot;node&quot;);
    mxmlNewText(node, 0, &quot;val3&quot;);

    group = mxmlNewElement(data, &quot;group&quot;);

        node = mxmlNewElement(group, &quot;node&quot;);
        mxmlNewText(node, 0, &quot;val4&quot;);
        node = mxmlNewElement(group, &quot;node&quot;);
        mxmlNewText(node, 0, &quot;val5&quot;);
        node = mxmlNewElement(group, &quot;node&quot;);
        mxmlNewText(node, 0, &quot;val6&quot;);

    node = mxmlNewElement(data, &quot;node&quot;);
    mxmlNewText(node, 0, &quot;val7&quot;);
    node = mxmlNewElement(data, &quot;node&quot;);
    mxmlNewText(node, 0, &quot;val8&quot;);
</code></pre>
<p>We start by creating the declaration node common to all XML files using the <code>mxmlNewXML</code> function:</p>
<pre><code>xml = mxmlNewXML(&quot;1.0&quot;);
</code></pre>
<p>We then create the <code>&lt;data&gt;</code> node used for this document using the <code>mxmlNewElement</code> function. The first argument specifies the parent node (<code>xml</code>) while the second specifies the element name (<code>data</code>):</p>
<pre><code>data = mxmlNewElement(xml, &quot;data&quot;);
</code></pre>
<p>Each <code>&lt;node&gt;...&lt;/node&gt;</code> in the file is created using the <code>mxmlNewElement</code> and <code>mxmlNewText</code> functions. The first argument of <code>mxmlNewText</code> specifies the parent node (<code>node</code>). The second argument specifies whether whitespace appears before the text - 0 or false in this case. The last argument specifies the actual text to add:</p>
<pre><code>node = mxmlNewElement(data, &quot;node&quot;);
mxmlNewText(node, 0, &quot;val1&quot;);
</code></pre>
<p>The resulting in-memory XML document can then be saved or processed just like one loaded from disk or a string.</p>
<h3 class="title" id="saving-an-xml-file">Saving an XML File</h3>
<p>You save an XML file using the <code>mxmlSaveFile</code> function:</p>
<pre><code>int
mxmlSaveFile(mxml_node_t *node, FILE *fp,
             mxml_save_cb_t cb);
</code></pre>
<p>The <code>cb</code> argument specifies a function that returns the whitespace (if any) that is inserted before and after each element node. The <code>MXML_NO_CALLBACK</code> constant tells Mini-XML to not include any extra whitespace. For example, so save an XML file to the file &quot;filename.xml&quot; with no extra whitespace:</p>
<pre><code>FILE *fp;

fp = fopen(&quot;filename.xml&quot;, &quot;w&quot;);
mxmlSaveFile(xml, fp, MXML_NO_CALLBACK);
fclose(fp);
</code></pre>
<p>Mini-XML also provides functions to save to a file descriptor or strings:</p>
<pre><code>char *
mxmlSaveAllocString(mxml_node_t *node, mxml_save_cb_t cb);

int
mxmlSaveFd(mxml_node_t *node, int fd, mxml_save_cb_t cb);

int
mxmlSaveString(mxml_node_t *node, char *buffer, int bufsize,
               mxml_save_cb_t cb);
</code></pre>
<h4 id="controlling-line-wrapping">Controlling Line Wrapping</h4>
<p>When saving XML documents, Mini-XML normally wraps output lines at column 75 so that the text is readable in terminal windows. The <code>mxmlSetWrapMargin</code> function overrides the default wrap margin for the current thread:</p>
<pre><code>void mxmlSetWrapMargin(int column);
</code></pre>
<p>For example, the following code sets the margin to 132 columns:</p>
<pre><code>mxmlSetWrapMargin(132);
</code></pre>
<p>while the following code disables wrapping by setting the margin to 0:</p>
<pre><code>mxmlSetWrapMargin(0);
</code></pre>
<h4 id="save-callbacks">Save Callbacks</h4>
<p>The last argument to the <code>mxmlSave</code> functions is a callback function which is used to automatically insert whitespace in an XML document. Your callback function will be called up to four times for each element node with a pointer to the node and a &quot;where&quot; value of <code>MXML_WS_BEFORE_OPEN</code>, <code>MXML_WS_AFTER_OPEN</code>, <code>MXML_WS_BEFORE_CLOSE</code>, or <code>MXML_WS_AFTER_CLOSE</code>. The callback function should return <code>NULL</code> if no whitespace should be added or the string to insert (spaces, tabs, carriage returns, and newlines) otherwise.</p>
<p>The following whitespace callback can be used to add whitespace to XHTML output to make it more readable in a standard text editor:</p>
<pre><code>const char *
whitespace_cb(mxml_node_t *node, int where)
{
  const char *element;

 /*
  * We can conditionally break to a new line before or after
  * any element.  These are just common HTML elements...
  */

  element = mxmlGetElement(node);

  if (!strcmp(element, &quot;html&quot;) ||
      !strcmp(element, &quot;head&quot;) ||
      !strcmp(element, &quot;body&quot;) ||
      !strcmp(element, &quot;pre&quot;) ||
      !strcmp(element, &quot;p&quot;) ||
      !strcmp(element, &quot;h1&quot;) ||
      !strcmp(element, &quot;h2&quot;) ||
      !strcmp(element, &quot;h3&quot;) ||
      !strcmp(element, &quot;h4&quot;) ||
      !strcmp(element, &quot;h5&quot;) ||
      !strcmp(element, &quot;h6&quot;))
  {
   /*
    * Newlines before open and after close...
    */

    if (where == MXML_WS_BEFORE_OPEN ||
        where == MXML_WS_AFTER_CLOSE)
      return (&quot;\n&quot;);
  }
  else if (!strcmp(element, &quot;dl&quot;) ||
           !strcmp(element, &quot;ol&quot;) ||
           !strcmp(element, &quot;ul&quot;))
  {
   /*
    * Put a newline before and after list elements...
    */

    return (&quot;\n&quot;);
  }
  else if (!strcmp(element, &quot;dd&quot;) ||
           !strcmp(element, &quot;dt&quot;) ||
           !strcmp(element, &quot;li&quot;))
  {
   /*
    * Put a tab before &lt;li&gt;'s, &lt;dd&gt;'s, and &lt;dt&gt;'s, and a
    * newline after them...
    */

    if (where == MXML_WS_BEFORE_OPEN)
      return (&quot;\t&quot;);
    else if (where == MXML_WS_AFTER_CLOSE)
      return (&quot;\n&quot;);
  }

 /*
  * Otherwise return NULL for no added whitespace...
  */

  return (NULL);
}
</code></pre>
<p>To use this callback function, simply use the name when you call any of the save functions:</p>
<pre><code>FILE *fp;
mxml_node_t *tree;

fp = fopen(&quot;filename.xml&quot;, &quot;w&quot;);
mxmlSaveFile(tree, fp, whitespace_cb);
fclose(fp);
</code></pre>
<h3 class="title" id="memory-management">Memory Management</h3>
<p>Once you are done with the XML data, use the <code>mxmlDelete</code> function to recursively free the memory that is used for a particular node or the entire tree:</p>
<pre><code>void
mxmlDelete(mxml_node_t *tree);
</code></pre>
<p>You can also use reference counting to manage memory usage. The <code>mxmlRetain</code> and <code>mxmlRelease</code> functions increment and decrement a node's use count, respectively. When the use count goes to zero, <code>mxmlRelease</code> automatically calls <code>mxmlDelete</code> to actually free the memory used by the node tree. New nodes start with a use count of 1.</p>
<h2 class="title" id="more-about-nodes">More About Nodes</h2>
<h3 class="title" id="element-nodes">Element Nodes</h3>
<p>Element (<code>MXML_ELEMENT</code>) nodes are created using the <code>mxmlNewElement</code> function. Element attributes are set using the <code>mxmlElementSetAttr</code> and <code>mxmlElementSetAttrf</code> functions and cleared using the <code>mxmlElementDeleteAttr</code> function:</p>
<pre><code>mxml_node_t *
mxmlNewElement(mxml_node_t *parent, const char *name);

void
mxmlElementDeleteAttr(mxml_node_t *node, const char *name);

void
mxmlElementSetAttr(mxml_node_t *node, const char *name,
                   const char *value);

void
mxmlElementSetAttrf(mxml_node_t *node, const char *name,
                    const char *format, ...);
</code></pre>
<p>Child nodes are added using the various <code>mxmlNew</code> functions. The top (root) node must be an element, usually created by the <code>mxmlNewXML</code> function:</p>
<pre><code>mxml_node_t *
mxmlNewXML(const char *version);
</code></pre>
<p>The <code>mxmlGetElement</code> function retrieves the element name, the <code>mxmlElementGetAttr</code> function retrieves the value string for a named attribute associated with the element. The <code>mxmlElementGetAttrByIndex</code> and <code>mxmlElementGetAttrCount</code> functions retrieve attributes by index:</p>
<pre><code>const char *
mxmlGetElement(mxml_node_t *node);

const char *
mxmlElementGetAttr(mxml_node_t *node, const char *name);

const char *
mxmlElementGetAttrByIndex(mxml_node_t *node, int idx,
                          const char **name);

int
mxmlElementGetAttrCount(mxml_node_t *node);
</code></pre>
<h3 class="title" id="cdata-nodes">CDATA Nodes</h3>
<p>CDATA (<code>MXML_ELEMENT</code>) nodes are created using the <code>mxmlNewCDATA</code> function:</p>
<pre><code>mxml_node_t *mxmlNewCDATA(mxml_node_t *parent, const char *string);
</code></pre>
<p>The <code>mxmlGetCDATA</code> function retrieves the CDATA string pointer for a node:</p>
<pre><code>const char *mxmlGetCDATA(mxml_node_t *node);
</code></pre>
<h3 class="title" id="comment-nodes">Comment Nodes</h3>
<p>Because comments are currently stored as element nodes, comment (<code>MXML_ELEMENT</code>) nodes are created using the <code>mxmlNewElement</code> function by including the surrounding &quot;!--&quot; and &quot;--&quot; characters in the element name, for example:</p>
<pre><code>mxml_node_t *node = mxmlNewElement(&quot;!-- This is a comment --&quot;);
</code></pre>
<p>Similarly, the <code>mxmlGetElement</code> function retrieves the comment string pointer for a node, which includes the surrounding &quot;!--&quot; and &quot;--&quot; characters.</p>
<pre><code>const char *comment = mxmlGetElement(node);
/* returns &quot;!-- This is a comment --&quot; */
</code></pre>
<h3 class="title" id="processing-instruction-nodes">Processing Instruction Nodes</h3>
<p>Because processing instructions are currently stored as element nodes, processing instruction (<code>MXML_ELEMENT</code>) nodes are created using the <code>mxmlNewElement</code> function including the surrounding &quot;?&quot; characters:</p>
<pre><code>mxml_node_t *node = mxmlNewElement(&quot;?xml-stylesheet type=\&quot;text/css\&quot; href=\&quot;style.css\&quot;?&quot;);
</code></pre>
<p>The <code>mxmlGetElement</code> function retrieves the processing instruction string for a node, including the surrounding &quot;?&quot; characters:</p>
<pre><code>const char *instr = mxmlGetElement(node);
/* returned &quot;?xml-stylesheet type=\&quot;text/css\&quot; href=\&quot;style.css\&quot;?&quot; */
</code></pre>
<h3 class="title" id="integer-nodes">Integer Nodes</h3>
<p>Integer (<code>MXML_INTEGER</code>) nodes are created using the <code>mxmlNewInteger</code> function:</p>
<pre><code>mxml_node_t *
mxmlNewInteger(mxml_node_t *parent, int integer);
</code></pre>
<p>The <code>mxmlGetInteger</code> function retrieves the integer value for a node:</p>
<pre><code>int
mxmlGetInteger(mxml_node_t *node);
</code></pre>
<h3 class="title" id="opaque-string-nodes">Opaque String Nodes</h3>
<p>Opaque string (<code>MXML_OPAQUE</code>) nodes are created using the <code>mxmlNewOpaque</code> function:</p>
<pre><code>mxml_node_t *
mxmlNewOpaque(mxml_node_t *parent, const char *opaque);
</code></pre>
<p>The <code>mxmlGetOpaque</code> function retrieves the opaque string pointer for a node:</p>
<pre><code>const char *
mxmlGetOpaque(mxml_node_t *node);
</code></pre>
<h3 class="title" id="text-nodes">Text Nodes</h3>
<p>Whitespace-delimited text string (<code>MXML_TEXT</code>) nodes are created using the <code>mxmlNewText</code> and <code>mxmlNewTextf</code> functions. Each text node consists of a text string and (leading) whitespace flag value.</p>
<pre><code>mxml_node_t *
mxmlNewText(mxml_node_t *parent, int whitespace,
            const char *string);

mxml_node_t *
mxmlNewTextf(mxml_node_t *parent, int whitespace,
             const char *format, ...);
</code></pre>
<p>The <code>mxmlGetText</code> function retrieves the text string pointer and whitespace flag value for a node:</p>
<pre><code> const char *
 mxmlGetText(mxml_node_t *node, int *whitespace);
</code></pre>
<h3 class="title" id="real-number-nodes">Real Number Nodes</h3>
<p>Real number (<code>MXML_REAL</code>) nodes are created using the <code>mxmlNewReal</code> function:</p>
<pre><code>mxml_node_t *
mxmlNewReal(mxml_node_t *parent, double real);
</code></pre>
<p>The <code>mxmlGetReal</code> function retrieves the real number for a node:</p>
<pre><code>double
mxmlGetReal(mxml_node_t *node);
</code></pre>
<h2 class="title" id="locating-data-in-an-xml-document">Locating Data in an XML Document</h2>
<p>Mini-XML provides many functions for enumerating, searching, and indexing XML documents.</p>
<h3 class="title" id="finding-nodes">Finding Nodes</h3>
<p>The <code>mxmlFindPath</code> function finds the (first) value node under a specific element using a &quot;path&quot;:</p>
<pre><code>mxml_node_t *
mxmlFindPath(mxml_node_t *node, const char *path);
</code></pre>
<p>The <code>path</code> string can contain the &quot;*&quot; wildcard to match a single element node in the hierarchy. For example, the following code will find the first &quot;node&quot; element under the &quot;group&quot; element, first using an explicit path and then using a wildcard:</p>
<pre><code>mxml_node_t *value = mxmlFindPath(xml, &quot;data/group/node&quot;);

mxml_node_t *value = mxmlFindPath(xml, &quot;data/*/node&quot;);
</code></pre>
<p>The <code>mxmlFindElement</code> function can be used to find a named element, optionally matching an attribute and value:</p>
<pre><code>mxml_node_t *
mxmlFindElement(mxml_node_t *node, mxml_node_t *top,
                const char *element, const char *attr,
                const char *value, int descend);
</code></pre>
<p>The &quot;element&quot;, &quot;attr&quot;, and &quot;value&quot; arguments can be passed as <code>NULL</code> to act as wildcards, e.g.:</p>
<pre><code>/* Find the first &quot;a&quot; element */
node = mxmlFindElement(tree, tree, &quot;a&quot;, NULL, NULL,
                       MXML_DESCEND);

/* Find the first &quot;a&quot; element with &quot;href&quot; attribute */
node = mxmlFindElement(tree, tree, &quot;a&quot;, &quot;href&quot;, NULL,
                       MXML_DESCEND);

/* Find the first &quot;a&quot; element with &quot;href&quot; to a URL */
node = mxmlFindElement(tree, tree, &quot;a&quot;, &quot;href&quot;,
                       &quot;http://michaelrsweet.github.io/&quot;,
                       MXML_DESCEND);

/* Find the first element with a &quot;src&quot; attribute*/
node = mxmlFindElement(tree, tree, NULL, &quot;src&quot;, NULL,
                       MXML_DESCEND);

/* Find the first element with a &quot;src&quot; = &quot;foo.jpg&quot; */
node = mxmlFindElement(tree, tree, NULL, &quot;src&quot;, &quot;foo.jpg&quot;,
                       MXML_DESCEND);
</code></pre>
<p>You can also iterate with the same function:</p>
<pre><code>mxml_node_t *node;

for (node = mxmlFindElement(tree, tree, &quot;element&quot;, NULL,
                            NULL, MXML_DESCEND);
     node != NULL;
     node = mxmlFindElement(node, tree, &quot;element&quot;, NULL,
                            NULL, MXML_DESCEND))
{
  ... do something ...
}
</code></pre>
<p>The <code>descend</code> argument (<code>MXML_DESCEND</code> in the examples above) can be one of three constants:</p>
<ul>
<li><p><code>MXML_NO_DESCEND</code>: ignore child nodes in the element hierarchy, instead using siblings (same level) or parent nodes (above) until the top (root) node is reached.</p>
</li>
<li><p><code>MXML_DESCEND_FIRST</code>: start the search with the first child of the node, and then search siblings. You'll normally use this when iterating through direct children of a parent node, e.g. all of the &quot;node&quot; and &quot;group&quot; elements under the &quot;?xml&quot; parent node in the previous example.</p>
</li>
<li><p><code>MXML_DESCEND</code>: search child nodes first, then sibling nodes, and then parent nodes.</p>
</li>
</ul>
<h3 class="title" id="iterating-nodes">Iterating Nodes</h3>
<p>While the <code>mxmlFindNode</code> and <code>mxmlFindPath</code> functions will find a particular element node, sometimes you need to iterate over all nodes. The <code>mxmlWalkNext</code> and <code>mxmlWalkPrev</code> functions can be used to iterate through the XML node tree:</p>
<pre><code>mxml_node_t *
mxmlWalkNext(mxml_node_t *node, mxml_node_t *top,
             int descend);

mxml_node_t *
mxmlWalkPrev(mxml_node_t *node, mxml_node_t *top,
             int descend);
</code></pre>
<p>Depending on the value of the <code>descend</code> argument, these functions will automatically traverse child, sibling, and parent nodes until the <code>top</code> node is reached. For example, the following code will iterate over all of the nodes in the sample XML document in the previous section:</p>
<pre><code>mxml_node_t *node;

for (node = xml;
     node != NULL;
     node = mxmlWalkNext(node, xml, MXML_DESCEND))
{
  ... do something ...
}
</code></pre>
<p>The nodes will be returned in the following order:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;data&gt;
&lt;node&gt;
val1
&lt;node&gt;
val2
&lt;node&gt;
val3
&lt;group&gt;
&lt;node&gt;
val4
&lt;node&gt;
val5
&lt;node&gt;
val6
&lt;node&gt;
val7
&lt;node&gt;
val8
</code></pre>
<h3 class="title" id="indexing">Indexing</h3>
<p>The <code>mxmlIndexNew</code> function allows you to create an index of nodes for faster searching and enumeration:</p>
<pre><code>mxml_index_t *
mxmlIndexNew(mxml_node_t *node, const char *element,
             const char *attr);
</code></pre>
<p>The <code>element</code> and <code>attr</code> arguments control which elements are included in the index. If <code>element</code> is not <code>NULL</code> then only elements with the specified name are added to the index. Similarly, if <code>attr</code> is not <code>NULL</code> then only elements containing the specified attribute are added to the index. The nodes are sorted in the index.</p>
<p>For example, the following code creates an index of all &quot;id&quot; values in an XML document:</p>
<pre><code>mxml_index_t *ind = mxmlIndexNew(xml, NULL, &quot;id&quot;);
</code></pre>
<p>Once the index is created, the <code>mxmlIndexFind</code> function can be used to find a matching node:</p>
<pre><code>mxml_node_t *
mxmlIndexFind(mxml_index_t *ind, const char *element,
              const char *value);
</code></pre>
<p>For example, the following code will find the element whose &quot;id&quot; string is &quot;42&quot;:</p>
<pre><code>mxml_node_t *node = mxmlIndexFind(ind, NULL, &quot;42&quot;);
</code></pre>
<p>Alternately, the <code>mxmlIndexReset</code> and <code>mxmlIndexEnum</code> functions can be used to enumerate the nodes in the index:</p>
<pre><code>mxml_node_t *
mxmlIndexReset(mxml_index_t *ind);

mxml_node_t *
mxmlIndexEnum(mxml_index_t *ind);
</code></pre>
<p>Typically these functions will be used in a <code>for</code> loop:</p>
<pre><code>mxml_node_t *node;

for (node = mxmlIndexReset(ind);
     node != NULL;
     node = mxmlIndexEnum(ind))
{
  ... do something ...
}
</code></pre>
<p>The <code>mxmlIndexCount</code> function returns the number of nodes in the index:</p>
<pre><code>int
mxmlIndexGetCount(mxml_index_t *ind);
</code></pre>
<p>Finally, the <code>mxmlIndexDelete</code> function frees all memory associated with the index:</p>
<pre><code>void
mxmlIndexDelete(mxml_index_t *ind);
</code></pre>
<h2 class="title" id="custom-data-types">Custom Data Types</h2>
<p>Mini-XML supports custom data types via per-thread load and save callbacks. Only a single set of callbacks can be active at any time for the current thread, however your callbacks can store additional information in order to support multiple custom data types as needed. The <code>MXML_CUSTOM</code> node type identifies custom data nodes.</p>
<p>The <code>mxmlGetCustom</code> function retrieves the custom value pointer for a node.</p>
<pre><code>const void *
mxmlGetCustom(mxml_node_t *node);
</code></pre>
<p>Custom (<code>MXML_CUSTOM</code>) nodes are created using the <code>mxmlNewCustom</code> function or using a custom per-thread load callbacks specified using the <code>mxmlSetCustomHandlers</code> function:</p>
<pre><code>typedef void (*mxml_custom_destroy_cb_t)(void *);
typedef int (*mxml_custom_load_cb_t)(mxml_node_t *, const char *);
typedef char *(*mxml_custom_save_cb_t)(mxml_node_t *);

mxml_node_t *
mxmlNewCustom(mxml_node_t *parent, void *data,
              mxml_custom_destroy_cb_t destroy);

int
mxmlSetCustom(mxml_node_t *node, void *data,
              mxml_custom_destroy_cb_t destroy);

void
mxmlSetCustomHandlers(mxml_custom_load_cb_t load,
                      mxml_custom_save_cb_t save);
</code></pre>
<p>The load callback receives a pointer to the current data node and a string of opaque character data from the XML source with character entities converted to the corresponding UTF-8 characters. For example, if we wanted to support a custom date/time type whose value is encoded as &quot;yyyy-mm-ddThh:mm:ssZ&quot; (ISO format), the load callback would look like the following:</p>
<pre><code>typedef struct
{
  unsigned year,    /* Year */
           month,   /* Month */
           day,     /* Day */
           hour,    /* Hour */
           minute,  /* Minute */
           second;  /* Second */
  time_t   unix;    /* UNIX time */
} iso_date_time_t;

int
load_custom(mxml_node_t *node, const char *data)
{
  iso_date_time_t *dt;
  struct tm tmdata;

 /*
  * Allocate data structure...
  */

  dt = calloc(1, sizeof(iso_date_time_t));

 /*
  * Try reading 6 unsigned integers from the data string...
  */

  if (sscanf(data, &quot;%u-%u-%uT%u:%u:%uZ&quot;, &amp;(dt-&gt;year),
             &amp;(dt-&gt;month), &amp;(dt-&gt;day), &amp;(dt-&gt;hour),
             &amp;(dt-&gt;minute), &amp;(dt-&gt;second)) != 6)
  {
   /*
    * Unable to read numbers, free the data structure and
    * return an error...
    */

    free(dt);

    return (-1);
  }

 /*
  * Range check values...
  */

  if (dt-&gt;month &lt; 1 || dt-&gt;month &gt; 12 ||
      dt-&gt;day &lt; 1 || dt-&gt;day &gt; 31 ||
      dt-&gt;hour &lt; 0 || dt-&gt;hour &gt; 23 ||
      dt-&gt;minute &lt; 0 || dt-&gt;minute &gt; 59 ||
      dt-&gt;second &lt; 0 || dt-&gt;second &gt; 60)
  {
   /*
    * Date information is out of range...
    */

    free(dt);

    return (-1);
  }

 /*
  * Convert ISO time to UNIX time in seconds...
  */

  tmdata.tm_year = dt-&gt;year - 1900;
  tmdata.tm_mon  = dt-&gt;month - 1;
  tmdata.tm_day  = dt-&gt;day;
  tmdata.tm_hour = dt-&gt;hour;
  tmdata.tm_min  = dt-&gt;minute;
  tmdata.tm_sec  = dt-&gt;second;

  dt-&gt;unix = gmtime(&amp;tmdata);

 /*
  * Assign custom node data and destroy (free) function
  * pointers...
  */

  mxmlSetCustom(node, data, free);

 /*
  * Return with no errors...
  */

  return (0);
}
</code></pre>
<p>The function itself can return 0 on success or -1 if it is unable to decode the custom data or the data contains an error. Custom data nodes contain a <code>void</code> pointer to the allocated custom data for the node and a pointer to a destructor function which will free the custom data when the node is deleted. In this example, we use the standard <code>free</code> function since everything is contained in a single calloc'd block.</p>
<p>The save callback receives the node pointer and returns an allocated string containing the custom data value. The following save callback could be used for our ISO date/time type:</p>
<pre><code>char *
save_custom(mxml_node_t *node)
{
  char data[255];
  iso_date_time_t *dt;


  dt = (iso_date_time_t *)mxmlGetCustom(node);

  snprintf(data, sizeof(data),
           &quot;%04u-%02u-%02uT%02u:%02u:%02uZ&quot;,
           dt-&gt;year, dt-&gt;month, dt-&gt;day, dt-&gt;hour,
           dt-&gt;minute, dt-&gt;second);

  return (strdup(data));
}
</code></pre>
<p>You register the callback functions using the <code>mxmlSetCustomHandlers</code> function:</p>
<pre><code>mxmlSetCustomHandlers(load_custom, save_custom);
</code></pre>
<h2 class="title" id="sax-stream-loading-of-documents">SAX (Stream) Loading of Documents</h2>
<p>Mini-XML supports an implementation of the Simple API for XML (SAX) which allows you to load and process an XML document as a stream of nodes. Aside from allowing you to process XML documents of any size, the Mini-XML implementation also allows you to retain portions of the document in memory for later processing.</p>
<p>The <code>mxmlSAXLoadFd</code>, <code>mxmlSAXLoadFile</code>, and <code>mxmlSAXLoadString</code> functions provide the SAX loading APIs:</p>
<pre><code>mxml_node_t *
mxmlSAXLoadFd(mxml_node_t *top, int fd,
              mxml_type_t (*cb)(mxml_node_t *),
              mxml_sax_cb_t sax, void *sax_data);

mxml_node_t *
mxmlSAXLoadFile(mxml_node_t *top, FILE *fp,
                mxml_type_t (*cb)(mxml_node_t *),
                mxml_sax_cb_t sax, void *sax_data);

mxml_node_t *
mxmlSAXLoadString(mxml_node_t *top, const char *s,
                  mxml_type_t (*cb)(mxml_node_t *),
                  mxml_sax_cb_t sax, void *sax_data);
</code></pre>
<p>Each function works like the corresponding <code>mxmlLoad</code> function but uses a callback to process each node as it is read. The callback function receives the node, an event code, and a user data pointer you supply:</p>
<pre><code>void
sax_cb(mxml_node_t *node, mxml_sax_event_t event,
       void *data)
{
  ... do something ...
}
</code></pre>
<p>The event will be one of the following:</p>
<ul>
<li><p><code>MXML_SAX_CDATA</code>: CDATA was just read.</p>
</li>
<li><p><code>MXML_SAX_COMMENT</code>: A comment was just read.</p>
</li>
<li><p><code>MXML_SAX_DATA</code>: Data (custom, integer, opaque, real, or text) was just read.</p>
</li>
<li><p><code>MXML_SAX_DIRECTIVE</code>: A processing directive/instruction was just read.</p>
</li>
<li><p><code>MXML_SAX_ELEMENT_CLOSE</code> - A close element was just read (<code>&lt;/element&gt;</code>)</p>
</li>
<li><p><code>MXML_SAX_ELEMENT_OPEN</code> - An open element was just read (<code>&lt;element&gt;</code>)</p>
</li>
</ul>
<p>Elements are <em>released</em> after the close element is processed. All other nodes are released after they are processed. The SAX callback can <em>retain</em> the node using the <code>mxmlRetain</code> function. For example, the following SAX callback will retain all nodes, effectively simulating a normal in-memory load:</p>
<pre><code>void
sax_cb(mxml_node_t *node, mxml_sax_event_t event,
       void *data)
{
  if (event != MXML_SAX_ELEMENT_CLOSE)
    mxmlRetain(node);
}
</code></pre>
<p>More typically the SAX callback will only retain a small portion of the document that is needed for post-processing. For example, the following SAX callback will retain the title and headings in an XHTML file. It also retains the (parent) elements like <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code>, and processing directives like <code>&lt;?xml ... ?&gt;</code> and <code>&lt;!DOCTYPE ... &gt;</code>:</p>
<pre><code>void
sax_cb(mxml_node_t *node, mxml_sax_event_t event,
       void *data)
{
  if (event == MXML_SAX_ELEMENT_OPEN)
  {
   /*
    * Retain headings and titles...
    */

    const char *element = mxmlGetElement(node);

    if (!strcmp(element, &quot;html&quot;) ||
        !strcmp(element, &quot;head&quot;) ||
        !strcmp(element, &quot;title&quot;) ||
        !strcmp(element, &quot;body&quot;) ||
        !strcmp(element, &quot;h1&quot;) ||
        !strcmp(element, &quot;h2&quot;) ||
        !strcmp(element, &quot;h3&quot;) ||
        !strcmp(element, &quot;h4&quot;) ||
        !strcmp(element, &quot;h5&quot;) ||
        !strcmp(element, &quot;h6&quot;))
      mxmlRetain(node);
  }
  else if (event == MXML_SAX_DIRECTIVE)
    mxmlRetain(node);
  else if (event == MXML_SAX_DATA)
  {
    if (mxmlGetRefCount(mxmlGetParent(node)) &gt; 1)
    {
     /*
      * If the parent was retained, then retain this data
      * node as well.
      */

      mxmlRetain(node);
    }
  }
}
</code></pre>
<p>The resulting skeleton document tree can then be searched just like one loaded using the <code>mxmlLoad</code> functions. For example, a filter that reads an XHTML document from stdin and then shows the title and headings in the document would look like:</p>
<pre><code>mxml_node_t *doc, *title, *body, *heading;

doc = mxmlSAXLoadFd(NULL, 0, MXML_TEXT_CALLBACK, sax_cb,
                    NULL);

title = mxmlFindElement(doc, doc, &quot;title&quot;, NULL, NULL,
                        MXML_DESCEND);

if (title)
  print_children(title);

body = mxmlFindElement(doc, doc, &quot;body&quot;, NULL, NULL,
                       MXML_DESCEND);

if (body)
{
  for (heading = mxmlGetFirstChild(body);
       heading;
       heading = mxmlGetNextSibling(heading))
    print_children(heading);
}
</code></pre>
<p>The <code>print_children</code> function is:</p>
<pre><code>void
print_children(mxml_node_t *parent)
{
  mxml_node_t *node;
  const char *text;
  int whitespace;

  for (node = mxmlGetFirstChild(parent);
       node != NULL;
       node = mxmlGetNextSibling(node))
  {
    text = mxmlGetText(node, &amp;whitespace);

    if (whitespace)
      putchar(' ');

    fputs(text, stdout);
  }

  putchar('\n');
}
</code></pre>
<h2 class="title"><a id="FUNCTIONS">Functions</a></h2>
<h3 class="function"><a id="mxmlAdd">mxmlAdd</a></h3>
<p class="description">Add a node to a tree.</p>
<p class="code">
void mxmlAdd(<a href="#mxml_node_t">mxml_node_t</a> *parent, int where, <a href="#mxml_node_t">mxml_node_t</a> *child, <a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node</td></tr>
<tr><th>where</th>
<td class="description">Where to add, <code>MXML_ADD_BEFORE</code> or <code>MXML_ADD_AFTER</code></td></tr>
<tr><th>child</th>
<td class="description">Child node for where or <code>MXML_ADD_TO_PARENT</code></td></tr>
<tr><th>node</th>
<td class="description">Node to add</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Adds the specified node to the parent.  If the child argument is not
<code>NULL</code>, puts the new node before or after the specified child depending
on the value of the where argument.  If the child argument is <code>NULL</code>,
puts the new node at the beginning of the child list (<code>MXML_ADD_BEFORE</code>)
or at the end of the child list (<code>MXML_ADD_AFTER</code>).  The constant
<code>MXML_ADD_TO_PARENT</code> can be used to specify a <code>NULL</code> child pointer.</p>
<h3 class="function"><a id="mxmlDelete">mxmlDelete</a></h3>
<p class="description">Delete a node and all of its children.</p>
<p class="code">
void mxmlDelete(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to delete</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If the specified node has a parent, this function first removes the
node from its parent using the <a href="#mxmlRemove"><code>mxmlRemove</code></a> function.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.4&#160;</span><a id="mxmlElementDeleteAttr">mxmlElementDeleteAttr</a></h3>
<p class="description">Delete an attribute.</p>
<p class="code">
void mxmlElementDeleteAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element</td></tr>
<tr><th>name</th>
<td class="description">Attribute name</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlElementGetAttr">mxmlElementGetAttr</a></h3>
<p class="description">Get an attribute.</p>
<p class="code">
const char *mxmlElementGetAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Attribute value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returns <code>NULL</code> if the node is not an element or the
named attribute does not exist.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.11&#160;</span><a id="mxmlElementGetAttrByIndex">mxmlElementGetAttrByIndex</a></h3>
<p class="description">Get an element attribute by index.</p>
<p class="code">
const char *mxmlElementGetAttrByIndex(<a href="#mxml_node_t">mxml_node_t</a> *node, int idx, const char **name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
<tr><th>idx</th>
<td class="description">Attribute index, starting at 0</td></tr>
<tr><th>name</th>
<td class="description">Attribute name</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Attribute value</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The index (&quot;idx&quot;) is 0-based.  <code>NULL</code> is returned if the specified index
is out of range.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.11&#160;</span><a id="mxmlElementGetAttrCount">mxmlElementGetAttrCount</a></h3>
<p class="description">Get the number of element attributes.</p>
<p class="code">
int mxmlElementGetAttrCount(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Number of attributes</p>
<h3 class="function"><a id="mxmlElementSetAttr">mxmlElementSetAttr</a></h3>
<p class="description">Set an attribute.</p>
<p class="code">
void mxmlElementSetAttr(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *name, const char *value);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
<tr><th>value</th>
<td class="description">Attribute value</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If the named attribute already exists, the value of the attribute
is replaced by the new string value. The string value is copied
into the element node. This function does nothing if the node is
not an element.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlElementSetAttrf">mxmlElementSetAttrf</a></h3>
<p class="description">Set an attribute with a formatted value.</p>
<p class="code">
void mxmlElementSetAttrf(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *name, const char *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Element node</td></tr>
<tr><th>name</th>
<td class="description">Name of attribute</td></tr>
<tr><th>format</th>
<td class="description">Printf-style attribute value</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If the named attribute already exists, the value of the attribute
is replaced by the new formatted string. The formatted string value is
copied into the element node. This function does nothing if the node
is not an element.

</p>
<h3 class="function"><a id="mxmlEntityAddCallback">mxmlEntityAddCallback</a></h3>
<p class="description">Add a callback to convert entities to Unicode.</p>
<p class="code">
int mxmlEntityAddCallback(<a href="#mxml_entity_cb_t">mxml_entity_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>cb</th>
<td class="description">Callback function to add</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h3 class="function"><a id="mxmlEntityGetName">mxmlEntityGetName</a></h3>
<p class="description">Get the name that corresponds to the character value.</p>
<p class="code">
const char *mxmlEntityGetName(int val);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>val</th>
<td class="description">Character value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Entity name or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If val does not need to be represented by a named entity, <code>NULL</code> is returned.</p>
<h3 class="function"><a id="mxmlEntityGetValue">mxmlEntityGetValue</a></h3>
<p class="description">Get the character corresponding to a named entity.</p>
<p class="code">
int mxmlEntityGetValue(const char *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>name</th>
<td class="description">Entity name</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Character value or -1 on error</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The entity name can also be a numeric constant. -1 is returned if the
name is not known.</p>
<h3 class="function"><a id="mxmlEntityRemoveCallback">mxmlEntityRemoveCallback</a></h3>
<p class="description">Remove a callback.</p>
<p class="code">
void mxmlEntityRemoveCallback(<a href="#mxml_entity_cb_t">mxml_entity_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>cb</th>
<td class="description">Callback function to remove</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlFindElement">mxmlFindElement</a></h3>
<p class="description">Find the named element.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlFindElement(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, const char *element, const char *attr, const char *value, int descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>element</th>
<td class="description">Element name or <code>NULL</code> for any</td></tr>
<tr><th>attr</th>
<td class="description">Attribute name, or <code>NULL</code> for none</td></tr>
<tr><th>value</th>
<td class="description">Attribute value, or <code>NULL</code> for any</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND</code>, <code>MXML_NO_DESCEND</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Element node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The search is constrained by the name, attribute name, and value; any
<code>NULL</code> names or values are treated as wildcards, so different kinds of
searches can be implemented by looking for all elements of a given name
or all elements with a specific attribute. The descend argument determines
whether the search descends into child nodes; normally you will use
<code>MXML_DESCEND_FIRST</code> for the initial search and <code>MXML_NO_DESCEND</code>
to find additional direct descendents of the node. The top node argument
constrains the search to a particular node's children.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlFindPath">mxmlFindPath</a></h3>
<p class="description">Find a node with the given path.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlFindPath(<a href="#mxml_node_t">mxml_node_t</a> *top, const char *path);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>path</th>
<td class="description">Path to element</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Found node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The &quot;path&quot; is a slash-separated list of element names. The name &quot;<em>" is
considered a wildcard for one or more levels of elements.  For example,
"foo/one/two", "bar/two/one", "</em>/one&quot;, and so forth.<br>
<br>
The first child node of the found node is returned if the given node has
children and the first child is a value node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetCDATA">mxmlGetCDATA</a></h3>
<p class="description">Get the value for a CDATA node.</p>
<p class="code">
const char *mxmlGetCDATA(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">CDATA value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node is not a CDATA element.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetCustom">mxmlGetCustom</a></h3>
<p class="description">Get the value for a custom node.</p>
<p class="code">
const void *mxmlGetCustom(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Custom value or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node (or its first child) is not a custom
value node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetElement">mxmlGetElement</a></h3>
<p class="description">Get the name for an element node.</p>
<p class="code">
const char *mxmlGetElement(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Element name or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node is not an element node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetFirstChild">mxmlGetFirstChild</a></h3>
<p class="description">Get the first child of an element node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetFirstChild(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First child or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node is not an element node or if the node
has no children.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetInteger">mxmlGetInteger</a></h3>
<p class="description">Get the integer value from the specified node or its
first child.</p>
<p class="code">
int mxmlGetInteger(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Integer value or 0</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">0 is returned if the node (or its first child) is not an integer value node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetLastChild">mxmlGetLastChild</a></h3>
<p class="description">Get the last child of an element node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetLastChild(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Last child or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node is not an element node or if the node
has no children.

</p>
<h3 class="function"><a id="mxmlGetNextSibling">mxmlGetNextSibling</a></h3>
<p class="description"></p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetNextSibling(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Get the next node for the current parent.</p>
<p class="discussion"><code>NULL</code> is returned if this is the last child for the current parent.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetOpaque">mxmlGetOpaque</a></h3>
<p class="description">Get an opaque string value for a node or its first child.</p>
<p class="code">
const char *mxmlGetOpaque(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Opaque string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node (or its first child) is not an opaque
value node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetParent">mxmlGetParent</a></h3>
<p class="description">Get the parent node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetParent(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Parent node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned for a root node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetPrevSibling">mxmlGetPrevSibling</a></h3>
<p class="description">Get the previous node for the current parent.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlGetPrevSibling(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Previous node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if this is the first child for the current parent.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetReal">mxmlGetReal</a></h3>
<p class="description">Get the real value for a node or its first child.</p>
<p class="code">
double mxmlGetReal(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Real value or 0.0</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">0.0 is returned if the node (or its first child) is not a real value node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetRefCount">mxmlGetRefCount</a></h3>
<p class="description">Get the current reference (use) count for a node.</p>
<p class="code">
int mxmlGetRefCount(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Reference count</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The initial reference count of new nodes is 1. Use the <a href="#mxmlRetain"><code>mxmlRetain</code></a>
and <a href="#mxmlRelease"><code>mxmlRelease</code></a> functions to increment and decrement a node's
reference count.

.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetText">mxmlGetText</a></h3>
<p class="description">Get the text value for a node or its first child.</p>
<p class="code">
const char *mxmlGetText(<a href="#mxml_node_t">mxml_node_t</a> *node, int *whitespace);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
<tr><th>whitespace</th>
<td class="description">1 if string is preceded by whitespace, 0 otherwise</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Text string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>NULL</code> is returned if the node (or its first child) is not a text node.
The &quot;whitespace&quot; argument can be <code>NULL</code>.<br>
<br>
Note: Text nodes consist of whitespace-delimited words. You will only get
single words of text when reading an XML file with <code>MXML_TEXT</code> nodes.
If you want the entire string between elements in the XML file, you MUST read
the XML file with <code>MXML_OPAQUE</code> nodes and get the resulting strings
using the <a href="#mxmlGetOpaque"><code>mxmlGetOpaque</code></a> function instead.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetType">mxmlGetType</a></h3>
<p class="description">Get the node type.</p>
<p class="code">
<a href="#mxml_type_t">mxml_type_t</a> mxmlGetType(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Type of node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion"><code>MXML_IGNORE</code> is returned if &quot;node&quot; is <code>NULL</code>.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlGetUserData">mxmlGetUserData</a></h3>
<p class="description">Get the user data pointer for a node.</p>
<p class="code">
void *mxmlGetUserData(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to get</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">User data pointer</p>
<h3 class="function"><a id="mxmlIndexDelete">mxmlIndexDelete</a></h3>
<p class="description">Delete an index.</p>
<p class="code">
void mxmlIndexDelete(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to delete</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlIndexEnum">mxmlIndexEnum</a></h3>
<p class="description">Return the next node in the index.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexEnum(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to enumerate</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Next node or <code>NULL</code> if there is none</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">You should call <a href="#mxmlIndexReset"><code>mxmlIndexReset</code></a> prior to using this function to get
the first node in the index.  Nodes are returned in the sorted order of the
index.</p>
<h3 class="function"><a id="mxmlIndexFind">mxmlIndexFind</a></h3>
<p class="description">Find the next matching node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexFind(<a href="#mxml_index_t">mxml_index_t</a> *ind, const char *element, const char *value);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to search</td></tr>
<tr><th>element</th>
<td class="description">Element name to find, if any</td></tr>
<tr><th>value</th>
<td class="description">Attribute value, if any</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Node or <code>NULL</code> if none found</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">You should call <a href="#mxmlIndexReset"><code>mxmlIndexReset</code></a> prior to using this function for
the first time with a particular set of &quot;element&quot; and &quot;value&quot;
strings. Passing <code>NULL</code> for both &quot;element&quot; and &quot;value&quot; is equivalent
to calling <a href="#mxmlIndexEnum"><code>mxmlIndexEnum</code></a>.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlIndexGetCount">mxmlIndexGetCount</a></h3>
<p class="description">Get the number of nodes in an index.</p>
<p class="code">
int mxmlIndexGetCount(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index of nodes</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Number of nodes in index</p>
<h3 class="function"><a id="mxmlIndexNew">mxmlIndexNew</a></h3>
<p class="description">Create a new index.</p>
<p class="code">
<a href="#mxml_index_t">mxml_index_t</a> *mxmlIndexNew(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *element, const char *attr);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">XML node tree</td></tr>
<tr><th>element</th>
<td class="description">Element to index or <code>NULL</code> for all</td></tr>
<tr><th>attr</th>
<td class="description">Attribute to index or <code>NULL</code> for none</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New index</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The index will contain all nodes that contain the named element and/or
attribute.  If both &quot;element&quot; and &quot;attr&quot; are <code>NULL</code>, then the index will
contain a sorted list of the elements in the node tree.  Nodes are
sorted by element name and optionally by attribute value if the &quot;attr&quot;
argument is not NULL.</p>
<h3 class="function"><a id="mxmlIndexReset">mxmlIndexReset</a></h3>
<p class="description">Reset the enumeration/find pointer in the index and
return the first node in the index.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlIndexReset(<a href="#mxml_index_t">mxml_index_t</a> *ind);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>ind</th>
<td class="description">Index to reset</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if there is none</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function should be called prior to using <a href="#mxmlIndexEnum"><code>mxmlIndexEnum</code></a> or
<a href="#mxmlIndexFind"><code>mxmlIndexFind</code></a> for the first time.</p>
<h3 class="function"><a id="mxmlLoadFd">mxmlLoadFd</a></h3>
<p class="description">Load a file descriptor into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFd(<a href="#mxml_node_t">mxml_node_t</a> *top, int fd, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>fd</th>
<td class="description">File descriptor to read from</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified file are added to the specified top node.
If no top node is provided, the XML file MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire file. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child (data) nodes of the specified type.<br>
<br>
Note: The most common programming error when using the Mini-XML library is
to load an XML file using the <code>MXML_TEXT_CALLBACK</code>, which returns inline
text as a series of whitespace-delimited words, instead of using the
<code>MXML_OPAQUE_CALLBACK</code> which returns the inline text as a single string
(including whitespace).</p>
<h3 class="function"><a id="mxmlLoadFile">mxmlLoadFile</a></h3>
<p class="description">Load a file into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadFile(<a href="#mxml_node_t">mxml_node_t</a> *top, FILE *fp, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>fp</th>
<td class="description">File to read from</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified file are added to the specified top node.
If no top node is provided, the XML file MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire file. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child (data) nodes of the specified type.<br>
<br>
Note: The most common programming error when using the Mini-XML library is
to load an XML file using the <code>MXML_TEXT_CALLBACK</code>, which returns inline
text as a series of whitespace-delimited words, instead of using the
<code>MXML_OPAQUE_CALLBACK</code> which returns the inline text as a single string
(including whitespace).</p>
<h3 class="function"><a id="mxmlLoadString">mxmlLoadString</a></h3>
<p class="description">Load a string into an XML node tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlLoadString(<a href="#mxml_node_t">mxml_node_t</a> *top, const char *s, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>s</th>
<td class="description">String to load</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the string has errors.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified string are added to the specified top node.
If no top node is provided, the XML string MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire string. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child (data) nodes of the specified type.<br>
<br>
Note: The most common programming error when using the Mini-XML library is
to load an XML file using the <code>MXML_TEXT_CALLBACK</code>, which returns inline
text as a series of whitespace-delimited words, instead of using the
<code>MXML_OPAQUE_CALLBACK</code> which returns the inline text as a single string
(including whitespace).</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlNewCDATA">mxmlNewCDATA</a></h3>
<p class="description">Create a new CDATA node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCDATA(<a href="#mxml_node_t">mxml_node_t</a> *parent, const char *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>data</th>
<td class="description">Data string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new CDATA node is added to the end of the specified parent's child
list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
CDATA node has no parent.  The data string must be nul-terminated and
is copied into the new node.  CDATA nodes currently use the
<code>MXML_ELEMENT</code> type.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.1&#160;</span><a id="mxmlNewCustom">mxmlNewCustom</a></h3>
<p class="description">Create a new custom data node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewCustom(<a href="#mxml_node_t">mxml_node_t</a> *parent, void *data, <a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a> destroy);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>data</th>
<td class="description">Pointer to data</td></tr>
<tr><th>destroy</th>
<td class="description">Function to destroy data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new custom node is added to the end of the specified parent's child
list. The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
element node has no parent. <code>NULL</code> can be passed when the data in the
node is not dynamically allocated or is separately managed.

</p>
<h3 class="function"><a id="mxmlNewElement">mxmlNewElement</a></h3>
<p class="description">Create a new element node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewElement(<a href="#mxml_node_t">mxml_node_t</a> *parent, const char *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>name</th>
<td class="description">Name of element</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new element node is added to the end of the specified parent's child
list. The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
element node has no parent.</p>
<h3 class="function"><a id="mxmlNewInteger">mxmlNewInteger</a></h3>
<p class="description">Create a new integer node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewInteger(<a href="#mxml_node_t">mxml_node_t</a> *parent, int integer);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>integer</th>
<td class="description">Integer value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new integer node is added to the end of the specified parent's child
list. The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
integer node has no parent.</p>
<h3 class="function"><a id="mxmlNewOpaque">mxmlNewOpaque</a></h3>
<p class="description">Create a new opaque string.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewOpaque(<a href="#mxml_node_t">mxml_node_t</a> *parent, const char *opaque);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>opaque</th>
<td class="description">Opaque string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new opaque string node is added to the end of the specified parent's
child list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that
the new opaque string node has no parent.  The opaque string must be nul-
terminated and is copied into the new node.</p>
<h3 class="function"><a id="mxmlNewOpaquef">mxmlNewOpaquef</a></h3>
<p class="description">Create a new formatted opaque string node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewOpaquef(<a href="#mxml_node_t">mxml_node_t</a> *parent, const char *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new opaque string node is added to the end of the specified parent's
child list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that
the new opaque string node has no parent.  The format string must be
nul-terminated and is formatted into the new node.</p>
<h3 class="function"><a id="mxmlNewReal">mxmlNewReal</a></h3>
<p class="description">Create a new real number node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewReal(<a href="#mxml_node_t">mxml_node_t</a> *parent, double real);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>real</th>
<td class="description">Real number value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new real number node is added to the end of the specified parent's
child list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that
the new real number node has no parent.</p>
<h3 class="function"><a id="mxmlNewText">mxmlNewText</a></h3>
<p class="description">Create a new text fragment node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewText(<a href="#mxml_node_t">mxml_node_t</a> *parent, int whitespace, const char *string);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>whitespace</th>
<td class="description">1 = leading whitespace, 0 = no whitespace</td></tr>
<tr><th>string</th>
<td class="description">String</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new text node is added to the end of the specified parent's child
list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
text node has no parent.  The whitespace parameter is used to specify
whether leading whitespace is present before the node.  The text
string must be nul-terminated and is copied into the new node.</p>
<h3 class="function"><a id="mxmlNewTextf">mxmlNewTextf</a></h3>
<p class="description">Create a new formatted text fragment node.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewTextf(<a href="#mxml_node_t">mxml_node_t</a> *parent, int whitespace, const char *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>parent</th>
<td class="description">Parent node or <code>MXML_NO_PARENT</code></td></tr>
<tr><th>whitespace</th>
<td class="description">1 = leading whitespace, 0 = no whitespace</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional args as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The new text node is added to the end of the specified parent's child
list.  The constant <code>MXML_NO_PARENT</code> can be used to specify that the new
text node has no parent.  The whitespace parameter is used to specify
whether leading whitespace is present before the node.  The format
string must be nul-terminated and is formatted into the new node.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlNewXML">mxmlNewXML</a></h3>
<p class="description">Create a new XML document tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlNewXML(const char *version);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>version</th>
<td class="description">Version number to use</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New ?xml node</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The &quot;version&quot; argument specifies the version number to put in the
?xml element node. If <code>NULL</code>, version &quot;1.0&quot; is assumed.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlRelease">mxmlRelease</a></h3>
<p class="description">Release a node.</p>
<p class="code">
int mxmlRelease(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New reference count</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">When the reference count reaches zero, the node (and any children)
is deleted via <a href="#mxmlDelete"><code>mxmlDelete</code></a>.

</p>
<h3 class="function"><a id="mxmlRemove">mxmlRemove</a></h3>
<p class="description">Remove a node from its parent.</p>
<p class="code">
void mxmlRemove(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to remove</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function does not free memory used by the node - use <a href="#mxmlDelete"><code>mxmlDelete</code></a>
for that.  This function does nothing if the node has no parent.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlRetain">mxmlRetain</a></h3>
<p class="description">Retain a node.</p>
<p class="code">
int mxmlRetain(<a href="#mxml_node_t">mxml_node_t</a> *node);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">New reference count</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlSAXLoadFd">mxmlSAXLoadFd</a></h3>
<p class="description">Load a file descriptor into an XML node tree
using a SAX callback.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadFd(<a href="#mxml_node_t">mxml_node_t</a> *top, int fd, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb, <a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb, void *sax_data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>fd</th>
<td class="description">File descriptor to read from</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
<tr><th>sax_cb</th>
<td class="description">SAX callback or <code>MXML_NO_CALLBACK</code></td></tr>
<tr><th>sax_data</th>
<td class="description">SAX user data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified file are added to the specified top node.
If no top node is provided, the XML file MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire file. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child nodes of the specified type.<br>
<br>
The SAX callback must call <a href="#mxmlRetain"><code>mxmlRetain</code></a> for any nodes that need to
be kept for later use. Otherwise, nodes are deleted when the parent
node is closed or after each data, comment, CDATA, or directive node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlSAXLoadFile">mxmlSAXLoadFile</a></h3>
<p class="description">Load a file into an XML node tree
using a SAX callback.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadFile(<a href="#mxml_node_t">mxml_node_t</a> *top, FILE *fp, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb, <a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb, void *sax_data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>fp</th>
<td class="description">File to read from</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
<tr><th>sax_cb</th>
<td class="description">SAX callback or <code>MXML_NO_CALLBACK</code></td></tr>
<tr><th>sax_data</th>
<td class="description">SAX user data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the file could not be read.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified file are added to the specified top node.
If no top node is provided, the XML file MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire file. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child nodes of the specified type.<br>
<br>
The SAX callback must call <a href="#mxmlRetain"><code>mxmlRetain</code></a> for any nodes that need to
be kept for later use. Otherwise, nodes are deleted when the parent
node is closed or after each data, comment, CDATA, or directive node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlSAXLoadString">mxmlSAXLoadString</a></h3>
<p class="description">Load a string into an XML node tree
using a SAX callback.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlSAXLoadString(<a href="#mxml_node_t">mxml_node_t</a> *top, const char *s, <a href="#mxml_load_cb_t">mxml_load_cb_t</a> cb, <a href="#mxml_sax_cb_t">mxml_sax_cb_t</a> sax_cb, void *sax_data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>s</th>
<td class="description">String to load</td></tr>
<tr><th>cb</th>
<td class="description">Callback function or constant</td></tr>
<tr><th>sax_cb</th>
<td class="description">SAX callback or <code>MXML_NO_CALLBACK</code></td></tr>
<tr><th>sax_data</th>
<td class="description">SAX user data</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">First node or <code>NULL</code> if the string has errors.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The nodes in the specified string are added to the specified top node.
If no top node is provided, the XML string MUST be well-formed with a
single parent node like <a href="?xml">?xml</a> for the entire string. The callback
function returns the value type that should be used for child nodes.
The constants <code>MXML_INTEGER_CALLBACK</code>, <code>MXML_OPAQUE_CALLBACK</code>,
<code>MXML_REAL_CALLBACK</code>, and <code>MXML_TEXT_CALLBACK</code> are defined for
loading child nodes of the specified type.<br>
<br>
The SAX callback must call <a href="#mxmlRetain"><code>mxmlRetain</code></a> for any nodes that need to
be kept for later use. Otherwise, nodes are deleted when the parent
node is closed or after each data, comment, CDATA, or directive node.

</p>
<h3 class="function"><a id="mxmlSaveAllocString">mxmlSaveAllocString</a></h3>
<p class="description">Save an XML tree to an allocated string.</p>
<p class="code">
char *mxmlSaveAllocString(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>cb</th>
<td class="description">Whitespace callback or <code>MXML_NO_CALLBACK</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Allocated string or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returns a pointer to a string containing the textual
representation of the XML node tree.  The string should be freed
using <code>free()</code> when you are done with it.  <code>NULL</code> is returned if the node
would produce an empty string or if the string cannot be allocated.<br>
<br>
The callback argument specifies a function that returns a whitespace
string or <code>NULL</code> before and after each element.  If <code>MXML_NO_CALLBACK</code>
is specified, whitespace will only be added before <code>MXML_TEXT</code> nodes
with leading whitespace and before attribute names inside opening
element tags.</p>
<h3 class="function"><a id="mxmlSaveFd">mxmlSaveFd</a></h3>
<p class="description">Save an XML tree to a file descriptor.</p>
<p class="code">
int mxmlSaveFd(<a href="#mxml_node_t">mxml_node_t</a> *node, int fd, <a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>fd</th>
<td class="description">File descriptor to write to</td></tr>
<tr><th>cb</th>
<td class="description">Whitespace callback or <code>MXML_NO_CALLBACK</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The callback argument specifies a function that returns a whitespace
string or NULL before and after each element. If <code>MXML_NO_CALLBACK</code>
is specified, whitespace will only be added before <code>MXML_TEXT</code> nodes
with leading whitespace and before attribute names inside opening
element tags.</p>
<h3 class="function"><a id="mxmlSaveFile">mxmlSaveFile</a></h3>
<p class="description">Save an XML tree to a file.</p>
<p class="code">
int mxmlSaveFile(<a href="#mxml_node_t">mxml_node_t</a> *node, FILE *fp, <a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>fp</th>
<td class="description">File to write to</td></tr>
<tr><th>cb</th>
<td class="description">Whitespace callback or <code>MXML_NO_CALLBACK</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on error.</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The callback argument specifies a function that returns a whitespace
string or NULL before and after each element. If <code>MXML_NO_CALLBACK</code>
is specified, whitespace will only be added before <code>MXML_TEXT</code> nodes
with leading whitespace and before attribute names inside opening
element tags.</p>
<h3 class="function"><a id="mxmlSaveString">mxmlSaveString</a></h3>
<p class="description">Save an XML node tree to a string.</p>
<p class="code">
int mxmlSaveString(<a href="#mxml_node_t">mxml_node_t</a> *node, char *buffer, int bufsize, <a href="#mxml_save_cb_t">mxml_save_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to write</td></tr>
<tr><th>buffer</th>
<td class="description">String buffer</td></tr>
<tr><th>bufsize</th>
<td class="description">Size of string buffer</td></tr>
<tr><th>cb</th>
<td class="description">Whitespace callback or <code>MXML_NO_CALLBACK</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Size of string</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">This function returns the total number of bytes that would be
required for the string but only copies (bufsize - 1) characters
into the specified buffer.<br>
<br>
The callback argument specifies a function that returns a whitespace
string or NULL before and after each element. If <code>MXML_NO_CALLBACK</code>
is specified, whitespace will only be added before <code>MXML_TEXT</code> nodes
with leading whitespace and before attribute names inside opening
element tags.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlSetCDATA">mxmlSetCDATA</a></h3>
<p class="description">Set the element name of a CDATA node.</p>
<p class="code">
int mxmlSetCDATA(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">New data string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not a CDATA element node.

</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.1&#160;</span><a id="mxmlSetCustom">mxmlSetCustom</a></h3>
<p class="description">Set the data and destructor of a custom data node.</p>
<p class="code">
int mxmlSetCustom(<a href="#mxml_node_t">mxml_node_t</a> *node, void *data, <a href="#mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a> destroy);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">New data pointer</td></tr>
<tr><th>destroy</th>
<td class="description">New destructor function</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not a custom node.

</p>
<h3 class="function"><a id="mxmlSetCustomHandlers">mxmlSetCustomHandlers</a></h3>
<p class="description">Set the handling functions for custom data.</p>
<p class="code">
void mxmlSetCustomHandlers(<a href="#mxml_custom_load_cb_t">mxml_custom_load_cb_t</a> load, <a href="#mxml_custom_save_cb_t">mxml_custom_save_cb_t</a> save);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>load</th>
<td class="description">Load function</td></tr>
<tr><th>save</th>
<td class="description">Save function</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The load function accepts a node pointer and a data string and must
return 0 on success and non-zero on error.<br>
<br>
The save function accepts a node pointer and must return a malloc'd
string on success and <code>NULL</code> on error.</p>
<h3 class="function"><a id="mxmlSetElement">mxmlSetElement</a></h3>
<p class="description">Set the name of an element node.</p>
<p class="code">
int mxmlSetElement(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *name);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>name</th>
<td class="description">New name string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it is not an element node.</p>
<h3 class="function"><a id="mxmlSetErrorCallback">mxmlSetErrorCallback</a></h3>
<p class="description">Set the error message callback.</p>
<p class="code">
void mxmlSetErrorCallback(<a href="#mxml_error_cb_t">mxml_error_cb_t</a> cb);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>cb</th>
<td class="description">Error callback function</td></tr>
</tbody></table>
<h3 class="function"><a id="mxmlSetInteger">mxmlSetInteger</a></h3>
<p class="description">Set the value of an integer node.</p>
<p class="code">
int mxmlSetInteger(<a href="#mxml_node_t">mxml_node_t</a> *node, int integer);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>integer</th>
<td class="description">Integer value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not an integer node.</p>
<h3 class="function"><a id="mxmlSetOpaque">mxmlSetOpaque</a></h3>
<p class="description">Set the value of an opaque node.</p>
<p class="code">
int mxmlSetOpaque(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *opaque);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>opaque</th>
<td class="description">Opaque string</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not an opaque node.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.11&#160;</span><a id="mxmlSetOpaquef">mxmlSetOpaquef</a></h3>
<p class="description">Set the value of an opaque string node to a formatted string.</p>
<p class="code">
int mxmlSetOpaquef(<a href="#mxml_node_t">mxml_node_t</a> *node, const char *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not an opaque node.

</p>
<h3 class="function"><a id="mxmlSetReal">mxmlSetReal</a></h3>
<p class="description">Set the value of a real number node.</p>
<p class="code">
int mxmlSetReal(<a href="#mxml_node_t">mxml_node_t</a> *node, double real);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>real</th>
<td class="description">Real number value</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not a real number node.</p>
<h3 class="function"><a id="mxmlSetText">mxmlSetText</a></h3>
<p class="description">Set the value of a text node.</p>
<p class="code">
int mxmlSetText(<a href="#mxml_node_t">mxml_node_t</a> *node, int whitespace, const char *string);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>whitespace</th>
<td class="description">1 = leading whitespace, 0 = no whitespace</td></tr>
<tr><th>string</th>
<td class="description">String</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not a text node.</p>
<h3 class="function"><a id="mxmlSetTextf">mxmlSetTextf</a></h3>
<p class="description">Set the value of a text node to a formatted string.</p>
<p class="code">
int mxmlSetTextf(<a href="#mxml_node_t">mxml_node_t</a> *node, int whitespace, const char *format, ...);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>whitespace</th>
<td class="description">1 = leading whitespace, 0 = no whitespace</td></tr>
<tr><th>format</th>
<td class="description">Printf-style format string</td></tr>
<tr><th>...</th>
<td class="description">Additional arguments as needed</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The node is not changed if it (or its first child) is not a text node.</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.7&#160;</span><a id="mxmlSetUserData">mxmlSetUserData</a></h3>
<p class="description">Set the user data pointer for a node.</p>
<p class="code">
int mxmlSetUserData(<a href="#mxml_node_t">mxml_node_t</a> *node, void *data);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Node to set</td></tr>
<tr><th>data</th>
<td class="description">User data pointer</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">0 on success, -1 on failure</p>
<h3 class="function"><span class="info">&#160;Mini-XML 2.3&#160;</span><a id="mxmlSetWrapMargin">mxmlSetWrapMargin</a></h3>
<p class="description">Set the wrap margin when saving XML data.</p>
<p class="code">
void mxmlSetWrapMargin(int column);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>column</th>
<td class="description">Column for wrapping, 0 to disable wrapping</td></tr>
</tbody></table>
<h4 class="discussion">Discussion</h4>
<p class="discussion">Wrapping is disabled when &quot;column&quot; is 0.

</p>
<h3 class="function"><a id="mxmlWalkNext">mxmlWalkNext</a></h3>
<p class="description">Walk to the next logical node in the tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkNext(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, int descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND</code>, <code>MXML_NO_DESCEND</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Next node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The descend argument controls whether the first child is considered
to be the next node.  The top node argument constrains the walk to
the node's children.</p>
<h3 class="function"><a id="mxmlWalkPrev">mxmlWalkPrev</a></h3>
<p class="description">Walk to the previous logical node in the tree.</p>
<p class="code">
<a href="#mxml_node_t">mxml_node_t</a> *mxmlWalkPrev(<a href="#mxml_node_t">mxml_node_t</a> *node, <a href="#mxml_node_t">mxml_node_t</a> *top, int descend);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>node</th>
<td class="description">Current node</td></tr>
<tr><th>top</th>
<td class="description">Top node</td></tr>
<tr><th>descend</th>
<td class="description">Descend into tree - <code>MXML_DESCEND</code>, <code>MXML_NO_DESCEND</code>, or <code>MXML_DESCEND_FIRST</code></td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">Previous node or <code>NULL</code></p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">The descend argument controls whether the previous node's last child
is considered to be the previous node.  The top node argument constrains
the walk to the node's children.</p>
<h2 class="title"><a id="TYPES">Data Types</a></h2>
<h3 class="typedef"><a id="mxml_custom_destroy_cb_t">mxml_custom_destroy_cb_t</a></h3>
<p class="description">Custom data destructor</p>
<p class="code">
typedef void (*mxml_custom_destroy_cb_t)(void *);
</p>
<h3 class="typedef"><a id="mxml_custom_load_cb_t">mxml_custom_load_cb_t</a></h3>
<p class="description">Custom data load callback function</p>
<p class="code">
typedef int (*mxml_custom_load_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, const char *);
</p>
<h3 class="typedef"><a id="mxml_custom_save_cb_t">mxml_custom_save_cb_t</a></h3>
<p class="description">Custom data save callback function</p>
<p class="code">
typedef char *(*mxml_custom_save_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *);
</p>
<h3 class="typedef"><a id="mxml_entity_cb_t">mxml_entity_cb_t</a></h3>
<p class="description">Entity callback function</p>
<p class="code">
typedef int (*mxml_entity_cb_t)(const char *);
</p>
<h3 class="typedef"><a id="mxml_error_cb_t">mxml_error_cb_t</a></h3>
<p class="description">Error callback function</p>
<p class="code">
typedef void (*mxml_error_cb_t)(const char *);
</p>
<h3 class="typedef"><a id="mxml_index_t">mxml_index_t</a></h3>
<p class="description">An XML node index.</p>
<p class="code">
typedef struct _mxml_index_s mxml_index_t;
</p>
<h3 class="typedef"><a id="mxml_load_cb_t">mxml_load_cb_t</a></h3>
<p class="description">Load callback function</p>
<p class="code">
typedef <a href="#mxml_type_t">mxml_type_t</a> (*mxml_load_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *);
</p>
<h3 class="typedef"><a id="mxml_node_t">mxml_node_t</a></h3>
<p class="description">An XML node.</p>
<p class="code">
typedef struct _mxml_node_s mxml_node_t;
</p>
<h3 class="typedef"><a id="mxml_save_cb_t">mxml_save_cb_t</a></h3>
<p class="description">Save callback function</p>
<p class="code">
typedef const char *(*mxml_save_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, int);
</p>
<h3 class="typedef"><a id="mxml_sax_cb_t">mxml_sax_cb_t</a></h3>
<p class="description">SAX callback function</p>
<p class="code">
typedef void (*mxml_sax_cb_t)(<a href="#mxml_node_t">mxml_node_t</a> *, mxml_sax_event_t, void *);
</p>
<h3 class="typedef"><a id="mxml_sax_event_t">mxml_sax_event_t</a></h3>
<p class="description">SAX event type.</p>
<p class="code">
typedef enum <a href="#mxml_sax_event_e">mxml_sax_event_e</a> mxml_sax_event_t;
</p>
<h3 class="typedef"><a id="mxml_type_t">mxml_type_t</a></h3>
<p class="description">The XML node type.</p>
<p class="code">
typedef enum <a href="#mxml_type_e">mxml_type_e</a> mxml_type_t;
</p>
<h2 class="title"><a id="ENUMERATIONS">Constants</a></h2>
<h3 class="enumeration"><a id="mxml_sax_event_e">mxml_sax_event_e</a></h3>
<p class="description">SAX event type.</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_SAX_CDATA </th><td class="description">CDATA node</td></tr>
<tr><th>MXML_SAX_COMMENT </th><td class="description">Comment node</td></tr>
<tr><th>MXML_SAX_DATA </th><td class="description">Data node</td></tr>
<tr><th>MXML_SAX_DIRECTIVE </th><td class="description">Processing directive node</td></tr>
<tr><th>MXML_SAX_ELEMENT_CLOSE </th><td class="description">Element closed</td></tr>
<tr><th>MXML_SAX_ELEMENT_OPEN </th><td class="description">Element opened</td></tr>
</tbody></table>
<h3 class="enumeration"><a id="mxml_type_e">mxml_type_e</a></h3>
<p class="description">The XML node type.</p>
<h4 class="constants">Constants</h4>
<table class="list"><tbody>
<tr><th>MXML_CUSTOM <span class="info">&#160;Mini-XML 2.1&#160;</span></th><td class="description">Custom data </td></tr>
<tr><th>MXML_ELEMENT </th><td class="description">XML element with attributes</td></tr>
<tr><th>MXML_IGNORE <span class="info">&#160;Mini-XML 2.3&#160;</span></th><td class="description">Ignore/throw away node </td></tr>
<tr><th>MXML_INTEGER </th><td class="description">Integer value</td></tr>
<tr><th>MXML_OPAQUE </th><td class="description">Opaque string</td></tr>
<tr><th>MXML_REAL </th><td class="description">Real value</td></tr>
<tr><th>MXML_TEXT </th><td class="description">Text fragment</td></tr>
</tbody></table>
</div>
</body>
</html>
